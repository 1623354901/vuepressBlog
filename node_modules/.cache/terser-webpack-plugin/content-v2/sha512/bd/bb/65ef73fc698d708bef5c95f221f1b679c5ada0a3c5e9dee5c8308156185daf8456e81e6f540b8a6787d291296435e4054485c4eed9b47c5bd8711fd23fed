{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{637:function(e,n,s){\"use strict\";s.r(n);var t=s(14),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"h3\",{attrs:{id:\"_1、es6模块化\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、es6模块化\"}},[e._v(\"#\")]),e._v(\" 1、ES6模块化\")]),e._v(\" \"),s(\"p\",[e._v(\"（1）模块化开发有AMD,CMD,common.js以及最新的ES6模块化\\n- AMD,CMD,common.js有开发者自己开发的，有局限性\\n- AMD,CMD用于浏览器的模块化开发\\n- COMMON.js 用于服务器端的模块化开发\\n- node.js中的导出 const 变量=exports('模块名'),导入module.require={},沿用的common.js中的模块化方法\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v(\"  - ES6 用来替代上述三种，\\n\")])])]),s(\"p\",[e._v(\"（2）ES6 模块化开发\\n有三种导出导入方式：默认导入导出，按需导入导出，直接导入\\n1> 默认导入导出\\n- 默认导入：export default{默认导出的成员}\\n- 默认导出：inport 接收名称 from ‘模块标识符’。模块标识符：路径或模块名\\n- 默认导出只能有一个export default\\n- 默认导入接收名称可以任意名称，只要是合法的成员名称\\n2> 按需导入导出\\n- 按需导入：export let a1=10;export let a2=10;\\n- 按需导出：inport {a1} from './m1.js'\\n- 每个模块中可以多次按需导出\\n- 按需导入成员名称和导出的名称应一致\\n- 按需导入可以使用as关键字重命名 import {a1 as aa} from './m1.js'\\n- 按需导入和默认导入可以一起使用 import info {a1} from './m1.js'\\n3> 直接导入并执行模块代码\\n- import './m1.js'\\n（3）ES6模块化开发注意事项\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"_2、promise\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、promise\"}},[e._v(\"#\")]),e._v(\" 2、promise\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v(\"(1) 回调地狱：多层回调函数的项目嵌套，形成回调地狱\\n    缺点：\\n    - 代码耦合性太强，难以维护\\n    - 代码冗余，可读性差\\n(2) promise :解决回调地狱\\n    1> promise是一个构造函数，\\n      - 实例：const p=new Promise() p为promise的实例，new出来一个实例代表一个异步操作\\n    2> promise的prototype包含.then(),.catch(),.finally();\\n      - 都可以通过原型链的方式访问到.then()方法。p.then();\\n    3> .then()方法用预先指定成功和失败的回调函数,成功的失败必传，失败的回调可选传与不传\\n      p.then(成功的回调函数，失败的回调函数)\\n      p.then(result=>{},error=>{})\\n(3) then-fs读取文件\\n    node.js fd读取文件仅支持回调地狱读取文件，不支持promise的调用方式，我们可以按照then-fs包，基于promise的方式读取文件,\\n    ```\\n    npm install then-fs\\n    import thenFs from 'then-fs'\\n    thenFs.readFile('./1.txt','utf8').then(r1=>{},err1=>{console.err1.message});.then(成功的回调，失败的回调)\\n    thenFs.readFile('./2.txt','utf8').then(r1=>{},err1=>{console.err1.message});\\n    thenFs.readFile('./3.txt','utf8').then(r1=>{},err1=>{console.err1.message});\\n    ```\\n    上述无法保证文件读取顺序\\n(4) 基于promise按顺序读取文件\\n    promise支持链式调用，解决回调地狱的问题\\n(5) Promise.prototype.catch() 用来捕获和处理错误\\n    .catch()如果放在.then后面，如果报错，会导致.then()中的代码无法实行。\\n    如果不希望前面的错误导致后续的.then无法正常执行，则可以将.catch()的调用提前，示例代码如下：\\n    ```\\n    thenfs.readFile('/files/11.txt','utf8')\\n    .catch(err=>{\\n      console.log(err.message)\\n    })\\n    .then(r1=>{\\n      console.log(\\\"111\\\");\\n    })\\n    .then(r2=>{\\n      console.log(\\\"222\\\");\\n    })\\n    //11.txt文件不存在，catch捕捉到错误，打印，后面继续输出111，222\\n    ```\\n(6)Promise.all()\\n  用来发起并行的Promise异步操作，等所有的异步操作全部结束后才会执行下一步的.then()操作(等待机制)\\n  ```\\n  import thenFs from 'then-fs'\\n  const promiseArr=[\\n    thenfs.readFile('./files/1.txt','utf8'),\\n    thenfs.readFile('./files/2.txt','utf8'),\\n    thenfs.readFile('./files/2.txt','utf8'),\\n  ];\\n  //需注意，数组中的顺序就是最终结果的顺序\\n  Promise.all(promiseArr).then(result=>{\\n    console.log(result)//所有文件读取成功才执行下一个.then()，等待机制\\n  }).catch(err=>{//捕获promise异步操作中的错误。\\n\\n  })\\n  ```\\n(7)Promise.race()赛跑机制，\\n  ```\\n  Promise.race(promiseArr).then(result=>{\\n  console.log(result)//只要任何一个读取完后就可以执行下一个.then(),赛跑机制\\n  }).catch(err=>{//捕获promise异步操作中的错误。\\n\\n  })\\n  ```\\n(8)基于Promise封装异步读取文件的方法\\n  要求：\\n  - 方法名称getFile\\n  - 方法接收一个形参fpath,表示要读取的文件的路径\\n  - 方法返回值为Promise实例对象\\n  ```\\n  // return new Promise()无法明确是ajax||文件，只是创建了一个形式上的异步操作\\n  //如果想要创建具体的异步操作，需要在new Promise()构造函数期间，传递一个funciton函数，将具体的异步操作定义到function函数中\\n  var that=this;\\n  function getFile(fpath){\\n    return new Promise(function(resolve,reject){\\n      false.readFile(fpath,'utf-8',(err,dataStr)=>{\\n        if(err){\\n          return reject(err)\\n        }\\n        resolve(dataStr)\\n      })\\n    })\\n  }\\n  //通过.then指定成功和失败的回调函数，可以在function的形参中进行接收\\n  getFile('./files/1.txt').then(dataStr=>{\\n  //成功的回调函数，传给形参resolve用的\\n    console.log(dataStr)\\n  },err=>{\\n  //失败的回调函数，传给形参reject用的\\n    console.log(err)\\n  }).catch(err=>{\\n    \\n  })\\n  ```\\n\")])])]),s(\"h3\",{attrs:{id:\"_3、async-await\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、async-await\"}},[e._v(\"#\")]),e._v(\" 3、async,await\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v(\"是ES8引入的新语法，用来简化promise异步操作，解决.then()代码冗余，阅读性差，不易理解的问题\\n如果某个方法的返回值promise实例对象，那么可以用await 用来修饰，修饰完成之后，这个方法变成一个值。\\n如果某个方法用await修饰，那么方法名必须用async修饰\\n```\\nimport thenFs from 'then-fs';\\ngetFile(){\\n  var r=thenFs.readFile('./files/1.txt','utf8);\\n  console.log(r)//r为一个promise实例对象    \\n}\\nasync function getFile(){\\n  var r1= await thenFs.readFile('./files/1.txt','utf8);\\n  console.log(r1)//r为一个promise实例对象    \\n  var r2= await thenFs.readFile('./files/2.txt','utf8);\\n  console.log(r2)\\n  var r3= await thenFs.readFile('./files/2.txt','utf8);\\n  console.log(r3)\\n}\\n```\\n注意事项\\n- 如果function中使用了await,那么function必须被async修饰\\n- 在async 方法中，第一个await之前的代码会同步执行，await之后的代码会异步执行\\n```\\nconsole.log('A');\\nasync function getFile(){\\n  console.log('B');\\n  到这之后异步执行，主线程退出当前方法，打印D,然后r1,r2,r3,执行完之后执行log(r1,r2,r3)，最后打印C\\n  var r1= await thenFs.readFile('./files/1.txt','utf8);\\n  var r2= await thenFs.readFile('./files/2.txt','utf8);\\n  var r3= await thenFs.readFile('./files/2.txt','utf8);\\n  console.log(r1,r2,r3);\\n  console.log('C');\\n}\\ngetFile();\\nconsole.log('D');\\n//打印顺序\\n//A,B,D,(111,222,333),C\\n\\n\\n```\\n\")])])]),s(\"h3\",{attrs:{id:\"_4、eventloop\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、eventloop\"}},[e._v(\"#\")]),e._v(\" 4、EventLoop\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v(' (1) javaSCript是一门单线程执行的编程语言，同一时间只能做一件事情\\n    单线程执行队列任务的问题：如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题\\n (2)同步任务和异步任务\\n    为了防止某个`耗时任务`导致`程序假死`的问题，javaScript把待执行的任务分为了两类：\\n    - 同步任务：\\n      - 又叫做`非耗时任务`，指的是在主线程上执行的那些任务\\n      - 只有前一个任务执行我完毕，才能执行后一个任务\\n    - 异步任务：\\n      - 又叫做`耗时任务`,异步任务由javaScript`委托给宿主环境`进行执行\\n      - 当异步任务执行完成后，会`通知javaScript主线程`执行异步任务的`回调函数`\\n (3)同步任务和异步任务的执行过程\\n    1> 同步任务由主线程执行\\n    2> 异步任务交给宿主环境去执行，\\n    3> 已完成的异步任务`对应的回调函数`，会被加入到任务队列中等待执行\\n    4> JavaScript主线程的执行栈被清空后，会读取任务队列中的回调函数，放到栈中，次序执行\\n    5> javaScript 主线程不断重复上面的第4步\\n    ```\\n    consloe.log(\"A\");同步任务\\n    fs.readFile(\\'./files/1.txt\\',utf8,cbA)//异步任务，在宿主环境中执行\\n    setTimeout(cbC,1000);//异步任务，在宿主环境中执行\\n    consloe.log(\"C\");同步任务\\n    //执行顺序：A,C,cbC,cbA。(cbA和cbC谁先执行完，谁先放到队列中)\\n    ``` \\n  EventLoop概念：`javaScript主线程从\"任务队列\"中读取异步任务的回调函数，放到执行栈中依次执行。`这个过程是循环不断的，所有整个的这种运行机制又称为EventLoop（事件循环）\\n')])])]),s(\"h3\",{attrs:{id:\"_5、宏任务和微任务\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、宏任务和微任务\"}},[e._v(\"#\")]),e._v(\" 5、宏任务和微任务\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v('  （1）JavaScript把异步任务又做了进一步划分，异步任务又分为两种：宏任务，微任务\\n      1> 宏任务\\n      - 异步Ajax请求\\n      - setTimeout,setInterval\\n      - 文件操作\\n      - 其他宏任务\\n      2> 微任务\\n      - Promise.then,.catch和.finally\\n      - process.nextTick\\n      - 其他微任务操作\\n  （2）宏任务和微任务的执行顺序：\\n                                ------------------无---------------\\n                              +                                    +\\n      宏任务==>执行完成==>是否有微任务--有--\\x3e执行完所有的微任务==>执行下一个宏任务\\n        +                                                           +\\n          ----------------------------------------------------------\\n      每个宏任务执行完成之后，都会检查`是否存在待执行的微任务`，如果有，则执行完所有微任务之后，再执行下一个宏任务\\n   （3）宏任务微任务业务场景--银行业务\\n      1> 小云和小腾去银行办理业务，首先取号排队                         --宏任务队列 \\n      2> 该银行网点只有一个柜员，小云在办理存款业务时，小腾只能等待       --单线程，宏任务按次序执行\\n      3> 小云办完存款业务之后，柜员询问他是否还想办理其他业务             --当前宏任务执行完，检查是否有微任务\\n      4> 小云告诉柜员：想要理财产品，办一张信用卡，最后再兑换点马年纪念币  -- 执行微任务，宏任务被推迟\\n      5> 小云离开柜台之后，柜员开始为小腾办理业务                        -- 所有微任务完成，开始执行下一个宏任务\\n   （4）面试题\\n      ```\\n        setTimeout(function(){\\n          console.log(\"1\");\\n        });\\n        new Promise(function(resolve){//同步任务，只要new一个Promise实例，里面的function就会立即执行\\n          console.log(\"2\");\\n          resolve();\\n        }).then(function(){//微任务\\n          console.log(\"3\")\\n        })\\n        console.log(\"4\")\\n        //同步任务（2，4）---》检查待执行的微任务（3）---》没有待执行的微任务，执行下一个宏任务（1）\\n        //2，4，3，1\\n\\n      ```\\n      ```\\n      console.log(\"1\");\\n      setTimeout(function(){\\n          console.log(\"2\");\\n          new Promise(function(resolve){\\n          console.log(\"3\");\\n          resolve();\\n        }).then(function(){\\n          console.log(\"4\")\\n        })\\n      });\\n      new Promise(function(resolve){\\n          console.log(\"5\");\\n          resolve();\\n      }).then(function(){\\n          console.log(\"6\")\\n      })\\n      setTimeout(function(){\\n          console.log(\"7\");\\n          new Promise(function(resolve){\\n          console.log(\"8\");\\n          resolve();\\n        }).then(function(){\\n          console.log(\"9\")\\n        })\\n      });\\n      //1,5,6,2,3,4,7,8,9\\n\\n      console.log(\"1\");                                   // 1 5 6 2 3 7 8 4 9\\n        setTimeout(function(){\\n            setTimeout(() => {\\n                console.log(\"2\");\\n            });\\n            new Promise(function(resolve){\\n            setTimeout(() => {\\n                console.log(\"3\");\\n            });\\n            resolve();\\n            }).then(function(){\\n                console.log(\"4\")\\n            })\\n        });\\n        new Promise(function(resolve){\\n            console.log(\"5\");\\n            resolve();\\n        }).then(function(){\\n            console.log(\"6\")\\n        })\\n        setTimeout(function(){\\n            console.log(\"7\");\\n            new Promise(function(resolve){\\n            console.log(\"8\");\\n            setTimeout(() => {\\n                resolve();\\n            });\\n        }).then(function(){\\n            console.log(\"9\")\\n        })\\n        });\\n      ```\\n')])])]),s(\"h2\",{attrs:{id:\"vue相关\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue相关\"}},[e._v(\"#\")]),e._v(\" vue相关\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"vue及脚手架\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue及脚手架\"}},[e._v(\"#\")]),e._v(\" vue及脚手架\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"webpack\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack\"}},[e._v(\"#\")]),e._v(\" webpack\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"webpack基本概念-使用步骤\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack基本概念-使用步骤\"}},[e._v(\"#\")]),e._v(\" webpack基本概念，使用步骤\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"_1、webpack作用\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、webpack作用\"}},[e._v(\"#\")]),e._v(\" 1、webpack作用\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"- 减少文件数量\\n- 压缩代码体积\\n- 提交浏览器打开的速度\\n\")])])]),s(\"h4\",{attrs:{id:\"_2、webpack基本概述\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、webpack基本概述\"}},[e._v(\"#\")]),e._v(\" 2、webpack基本概述\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"本质是一个第三方模块包，用于分析，并打包代码\\n- 支持所有类型的文件\\n- 支持less/sass=>css\\n- 支持ES6/7/8=>ES5 代码降级处理，兼容通用\\n- 压缩代码，提高加载速度\\n\")])])]),s(\"h4\",{attrs:{id:\"_3、环境准备\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、环境准备\"}},[e._v(\"#\")]),e._v(\" 3、环境准备\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('- 初始化包环境-yarn init(yarn比npm快)\\n- 安装依赖包- yarn add webpack webpack-cli -D(-D:把两个包的版本记录到开发环境)\\n- package.json中加入\\n​```\\n\"script\":{\\n  \"build\":\"webpack\"\\n}\\n​```\\n')])])]),s(\"h3\",{attrs:{id:\"webpack配置\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack配置\"}},[e._v(\"#\")]),e._v(\" webpack配置\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"_1、修改默认入口和出口\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、修改默认入口和出口\"}},[e._v(\"#\")]),e._v(\" 1、修改默认入口和出口\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"默认配置文件：新建webpack.config.js\")]),e._v(\" \"),s(\"li\",[e._v(\"填入配置\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   const path=require(\\\"path\\\");//node内部核心模块，处理路径用的\\n   module.exports={\\n      enter:'./src/main.js',//入口\\n      output:{//出口\\n         path:path.resolve(__dirname,'dist'),//__dirname:获取当前项目绝对路径，//dist：出口文件夹名字\\n         filename:'bundle.js'//出口文件名称\\n      },\\n      \\n   }\\n\")])])]),s(\"ul\",[s(\"li\",[e._v(\"同时修改入口文件名：index.js==>main.js\")])]),e._v(\" \"),s(\"h4\",{attrs:{id:\"_2、打包流程\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、打包流程\"}},[e._v(\"#\")]),e._v(\" 2、打包流程\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"npm run build==>num run webpack==>根据配置文件得到配置参数，（如果没有配置文件，用默认的。）==>执行默认文件配置，找到入口==>先构建依赖关键图，编译各个模块的文件==>输出到指定出口文件\\n注意：`所有要被打包的资源都要跟入口产生直接/简介的引用关系`--所有文件都要引到入口文件中\\n\")])])]),s(\"h4\",{attrs:{id:\"_3、自动生成html文件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、自动生成html文件\"}},[e._v(\"#\")]),e._v(\" 3、自动生成html文件\")]),e._v(\" \"),s(\"p\",[e._v(\"html-webpack-plugin插件：简化html文件的创建\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"安装：npm install --save-dev html-webpack-plugin //--save-dev保存到开发环境\")]),e._v(\" \"),s(\"li\",[e._v(\"用法：先引入组件，在module.exports中的plugins中new一个新的HtmlWebpackPlugin并写明html文件\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   const path=require(\\\"path\\\");//node内部核心模块，处理路径用的\\n   const HtmlWebpackPlugin=require(\\\"html-webpack-plugin\\\");\\n   module.exports={\\n    entry:'./src/main.js',//入口\\n    output:{//出口\\n        path:path.resolve(__dirname,'dist'),//__dirname:获取当前项目绝对路径，//dist：出口文件夹名字\\n        filename:'bundle.js'//出口文件名称\\n    },\\n    plugins:[\\n        new HtmlWebpackPlugin({\\n            template:'./public/index.html'//告诉webpack使用插件时，以我们自己的html文件作为模板去生成dist/html文件\\n        })\\n    ]\\n    \\n}\\n\")])])]),s(\"h4\",{attrs:{id:\"_4、webpack加载器-打包css文件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、webpack加载器-打包css文件\"}},[e._v(\"#\")]),e._v(\" 4、webpack加载器-打包css文件\")]),e._v(\" \"),s(\"p\",[e._v(\"webpack默认只能处理js文件，所以需要引入加载器\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"安装：npm install --save-dev css-loader--让webpack能处理css类型的文件\\nnpm install --save-dev style-loader--把css插入到DOM中\\n建议两个同时使用\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('   module: {//加载器\\n        rules: [//规则\\n          {//一个具体的规则\\n            test: /\\\\.css$/i,//匹配.css结尾的文件，忽略大小写\\n            use: [\"style-loader\", \"css-loader\"],//让webpack使用这两个处理css文件\\n            //从右到左，所以两者位置不能颠倒\\n            //css-loader:webpack解析css文件-把css代码一起打包进js中\\n            // style-loader:css代码插入到DOM中(style标签)\\n          },\\n        ],\\n      },\\n')])])]),s(\"h4\",{attrs:{id:\"_5、less-loader\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、less-loader\"}},[e._v(\"#\")]),e._v(\" 5、less-loader\")]),e._v(\" \"),s(\"p\",[e._v(\"将less转为css\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"安装：npm install less less-loader --save-dev --下载less包及加载器\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('   module: {//加载器\\n        rules: [//规则\\n          {//一个具体的规则\\n            test: /\\\\.css$/i,//匹配.css结尾的文件，忽略大小写\\n            use: [\"style-loader\", \"css-loader\"],//让webpack使用这两个处理css文件\\n            //从右到左，所以两者位置不能颠倒\\n            //css-loader:webpack解析css文件-把css代码一起打包进js中\\n            //style-loader:css代码插入到DOM中(style标签)\\n          },\\n          {//一个具体的规则\\n            test: /\\\\.less$/i,\\n            use: [\"style-loader\", \"css-loader\",\"less-loader\"],\\n          },\\n        ],\\n      },\\n')])])]),s(\"h4\",{attrs:{id:\"_6、webpack处理图片-配置asset\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6、webpack处理图片-配置asset\"}},[e._v(\"#\")]),e._v(\" 6、webpack处理图片--配置asset\")]),e._v(\" \"),s(\"p\",[e._v(\"webpack5：\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   //在module.rules下：\\n   {//图片文件的配置（仅适用于webpack5)\\n            test:/\\\\.(jpg|gif|png|jpeg)/,\\n            type:'asset'//匹配上面的文件后，webpack会把他们当作静态资源处理打包\\n\\n   }\\n   //如果设置的是asset模式，\\n   // 以8KB大小区分图片文件，\\n   // 小于8KB的，把图片文件转为base64,打包进js中\\n   // 大于8kb的，直接把图片文件输出到dist下\\n\")])])]),s(\"p\",[e._v(\"webpack4及以下；用url-loader和file-loader\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"_7、webpack处理图片的优缺点\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7、webpack处理图片的优缺点\"}},[e._v(\"#\")]),e._v(\" 7、webpack处理图片的优缺点：\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"图片翻译成base64，放到了js文件中：\\n\"),s(\"ul\",[s(\"li\",[e._v(\"好处：浏览器不用发送请求了，直接可以读取，速度快\")]),e._v(\" \"),s(\"li\",[e._v(\"坏处：图片太大，再转‘base64’就会让图片的体积增大30%左右，得不偿失\")])])])]),e._v(\" \"),s(\"h4\",{attrs:{id:\"_8、webpack处理字体图标\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8、webpack处理字体图标\"}},[e._v(\"#\")]),e._v(\" 8、webpack处理字体图标\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   //在module.rules下：\\n   {\\n      test:/\\\\.(eot|svg|ttf|woff|woff2)$/,\\n      type:'asset/resource',//所以的字体图标文件，都输出到dist下\\n      generator:{//生成文件的名字-定义规则\\n         filename:'fonts/[name].[hash:6][ext]'//fonts目录下原来自己的名字+六位随机哈希值+自己文件后缀\\n      }\\n      }\\n\")])])]),s(\"h4\",{attrs:{id:\"_9、webpack加载器-babel降级js语法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9、webpack加载器-babel降级js语法\"}},[e._v(\"#\")]),e._v(\" 9、webpack加载器-babel降级js语法\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"babel:https://www.babeljs.cn/docs/\")]),e._v(\" \"),s(\"li\",[e._v(\"babel-loader:https://webpack.docschina.org/loaders/babel-loader/\")]),e._v(\" \"),s(\"li\",[e._v(\"安装：npm install -D babel-loader @babel/core @babel/preset-env\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   //在module.rules下\\n   {\\n      test: /\\\\.m?js$/,\\n      exclude: /(node_modules|bower_components)/,//不去匹配这些文件夹下的文见\\n      use: {\\n         loader: 'babel-loader',//使用这个loader处理js文件\\n         options: {//加载器选项\\n            presets: ['@babel/preset-env']//预设：@babel/preset-env降级规则-安装这里的规则降级我们的js语法\\n         }\\n      }\\n   }\\n\")])])]),s(\"h3\",{attrs:{id:\"webpack开发服务器\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack开发服务器\"}},[e._v(\"#\")]),e._v(\" webpack开发服务器\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"减少打包时间，实时更新代码\")]),e._v(\" \"),s(\"li\",[e._v(\"webpack-dev-server:https://webpack.docschina.org/configuration/dev-server/\")]),e._v(\" \"),s(\"li\",[e._v(\"下载安装:npm install -D webpack-dev-server\")]),e._v(\" \"),s(\"li\",[e._v(\"自定义webpack开发服务器启动命令serve--在package.json里\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('   \"scripts\": {\\n    \"build\": \"webpack\",\\n    \"serve\":\"webpack serve\"\\n   },\\n')])])]),s(\"p\",[e._v(\"在webpack.config.js\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"   //在module.exports下\\n   devServer:{\\n      port:3000,\\n    }\\n\")])])]),s(\"h3\",{attrs:{id:\"vue\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue\"}},[e._v(\"#\")]),e._v(\" vue\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"更少的时间，干更多的活，开发速度快\\nvue是渐进式框架：渐进：逐渐使用，逐渐进步\\n声明式渲染-组件系统-客户端路由-大规模状态管理-构建工具\\n\")])])]),s(\"h3\",{attrs:{id:\"vue脚手架\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue脚手架\"}},[e._v(\"#\")]),e._v(\" vue脚手架\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"搭建命令\\n​```\\nnpm global install @vue/cli\\nvue creat vueli-demo\\n​```\\n运行命令\\n​```\\nnpm run serve\\n​```\\n脚手架目录作用\\n- node_modules-下载的第三方包\\n- public 静态文件目录\\n  - index.html 网页浏览的页面\\n- src 业务文件夹\\n  - assets 静态文件\\n  - components 组件文件夹\\n  - app.vue 整个项目的根组件\\n  - main.js 入口js文件\\n- .gitignore git提交忽略配置\\n- babel.config.js babel设置\\n- package.json 依赖包列表\\n\")])])]),s(\"h3\",{attrs:{id:\"vue开发服务器\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue开发服务器\"}},[e._v(\"#\")]),e._v(\" vue开发服务器\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"在vue.config.js写入：\\n​```\\nmodules.exports{\\n  devServer:{\\n    port:3000,\\n    open:true//浏览器自动打开\\n  }\\n}\\n​```\\n\")])])]),s(\"h3\",{attrs:{id:\"vue-eslint\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-eslint\"}},[e._v(\"#\")]),e._v(\" vue-eslint\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"代码检查工具，如何关闭？在vue.config.js中加入配置\\n​```\\nmodules.exports{\\n  devServer:{\\n    port:3000,\\n    open:true//浏览器自动打开\\n  },\\n  lintOnSave:false//关闭eslint校验\\n}\\n​```\\n\")])])]),s(\"p\",[e._v(\"1、差值表达式\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"- 在dom标签中，直接插入vue数据变量\\n- 又叫声明式渲染/文本差值\\n- 语法：{{表达式}}\\n\")])])]),s(\"h3\",{attrs:{id:\"_2、mvvm设计模式\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、mvvm设计模式\"}},[e._v(\"#\")]),e._v(\" 2、MVVM设计模式\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"- 数据驱动视图\\n- 设计模式：对代码进行分层，引入一种框架的概念\\n- MVVM 是模型，视图，视图模型双向关联的一种设计模式\\n- M:数据层（data）,V:视图层（template），VM:调度者\\n\")])])]),s(\"h3\",{attrs:{id:\"_3、v-bind绑定属性\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、v-bind绑定属性\"}},[e._v(\"#\")]),e._v(\" 3、v-bind绑定属性\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('- v-bind:属性名=\"vue变量\"\\n- 简化：:bind:属性名=\"vue变量\"\\n')])])]),s(\"h3\",{attrs:{id:\"_4、v-on绑定事件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、v-on绑定事件\"}},[e._v(\"#\")]),e._v(\" 4、v-on绑定事件\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('- 语法：\\n  v-on:事件名=\"要执行的少量代码\"\\n  v-on:事件名=\"methods里的函数名\"\\n  v-on:事件名=\"methods里的函数名（参数）\"\\n- 简写：@事件名=\"methods里的函数名\"\\n- 接收事件对象\\n  1、@click=\"one\"  ==>事件触发无传值，在方法中可以直接用形参接事件对象\\n    ```\\n    one(e){\\n      e.preventDefault()//阻止默认点击事件\\n    }\\n    ```\\n  2、@click=\"twe(10,$event)\"  ==>事件触发有传值，需要手动传入$event\\n')])])]),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",[s(\"code\",[e._v(\"twe(num e){\\n  e.preventDefault()\\n}\\n```\\n\")])])]),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 5、修饰符\\n\\n\")])])]),s(\"p\",[e._v(\"在事件后面.修饰符-给事件带来更强大的功能\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v('语法：@事件名.修饰符=\"methods里的函数\"')]),e._v(\" \"),s(\"li\",[e._v(\"修饰符列表：\\n\"),s(\"ul\",[s(\"li\",[e._v(\".stop：阻止事件冒泡\")]),e._v(\" \"),s(\"li\",[e._v(\".preven：阻止默认行为\")]),e._v(\" \"),s(\"li\",[e._v(\".once：程序运行期间，只触发一次事件处理函数\")])])])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 6、按键修饰符\\n\\n\")])])]),s(\"p\",[e._v('@键盘事件.修饰符=\"methods里的函数名\"')]),e._v(\" \"),s(\"p\",[e._v('@keyup.enter=\"methods里的函数名\"; --按下起来\\n@keydown.esc=\"methods里的函数名\"--按下\\n更多修饰符：https://cn.vuejs.org/v2/guide/event.html')]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 7、v-model\\n\\n\")])])]),s(\"p\",[e._v('语法：v-model=\"Vue数据变量\"')]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[e._v(\"双向数据绑定\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"变量变化--》视图自动同步\")]),e._v(\" \"),s(\"li\",[e._v(\"视图变化--》变量自动同步\")])])]),e._v(\" \"),s(\"li\",[s(\"p\",[e._v(\"下拉菜单要绑定在select上，option中的value与v-model关联\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[e._v(\"复选框v-model的变量值：非数组-关联的是复选框的checked属性； 数组-关联的是复选框的value属性\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[e._v(\"单选框，同一组radio必须有同名的name值，与选中的value关联\")])])]),e._v(\" \"),s(\"p\",[e._v('v-model修饰符\\n语法：v-model.修饰符=\"vue数据变量\"')]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\".number --以parseFloat转成数字类型\")]),e._v(\" \"),s(\"li\",[e._v(\".trim   --去除首尾空白字符\")]),e._v(\" \"),s(\"li\",[e._v(\".lazy   --在change时触发而非input时\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 8、v-text和v-html\\n\\n\")])])]),s(\"p\",[e._v(\"innerText和innerHTML区别：前者当做普通字符串直接显示，后者当做标签进行解析再显示\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"v-text:直接显示\")]),e._v(\" \"),s(\"li\",[e._v(\"v-html:当成标签解析显示\\n两者会覆盖差值表达式\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 9、v-if和v-show\\n\\n\")])])]),s(\"p\",[e._v(\"控制标签的隐藏和显示\\n区别：\\nv-if:DOM树上直接移除（移除不要）\\nv-show:通过设置display:none的值来控制（频繁切换，性能更好）\\nv-if和v-else能一起使用\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 10、v-for\\n\\n\")])])]),s(\"p\",[e._v('语法：v-for=\"(值变量,索引变量) in 目标结构\" 想要谁循环，放在谁身上\\n可以遍历 数组，对象，数字\\n对象语法：v-for=\"(value,key) in 对象\"')]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n### 11、v-for更新检测，key作用\\n\\n## 面试题\\n\\n### 1. Vue的最大优势是什么?\\n\\n​\\t简单易学, 轻量级整个源码js文件不大, 双向数据绑定, 数据驱动视图, 组件化, 数据和视图分离, \\n\\n​\\tvue负责关联视图和数据, 作者中国人(尤雨溪), 文档都是中文的, 入门教程非常多, 上手简单. \\n\\n​\\t相比传统网页, vue是单页面可以只刷新某一部分\\n\\n### 2. Vue和jQuery区别是什么?\\n\\n​\\tjQuery应该算是一个插件, 里面封装了各种易用的方法, 方便你使用更少的代码来操作dom标签\\n\\n​\\tVue是一套框架, 有自己的规则和体系与语法, 特别是设计思想MVVM, 让数据和视频关联绑定, 省略了很多DOM操作. 然后指令还给标签注入了更多的功能\\n\\n### 3. mvvm和mvc区别是什么?\\n\\n​\\tMVC: 也是一种设计模式, 组织代码的结构, 是model数据模型, view视图, Controller控制器, 在控制器这层里编写js代码, 来控制数据和视图关联\\n\\n​\\tMVVM: 即Model-View-ViewModel的简写。即模型-视图-视图模型, VM是这个设计模式的核心, 连接v和m的桥梁, 内部会监听DOM事件, 监听数据对象变化来影响对方. 我们称之为数据绑定\\n\\n### 4. Vue常用修饰符有哪些?\\n\\n​    .prevent: 提交事件不再重载页面；\\n\\n​\\t.stop: 阻止单击事件冒泡；\\n\\n​\\t.once: 只执行一次这个事件\\n\\n### 5. Vue2.x兼容IE哪个版本以上\\n\\n​\\t不支持ie8及以下，部分兼容ie9 ，完全兼容10以上， 因为vue的响应式原理是基于es5的Object.defineProperty(),而这个方法不支持ie8及以下。\\n\\n### 6. 对Vue渐进式的理解\\n\\n​\\t渐进式代表的含义是：主张最少, 自底向上, 增量开发, 组件集合, 便于复用\\n\\n### 7. v-show和v-if的区别\\n\\n​\\tv-show和v-if的区别? 分别说明其使用场景?\\n\\n​\\tv-show 和v-if都是true的时候显示，false的时候隐藏\\n\\n​\\t但是：false的情况下，\\n\\n​\\tv-show是采用的display:none   \\n\\n​\\tv-if采用惰性加载\\n\\n​\\t如果需要频繁切换显示隐藏需要使用v-show\\n\\n### 8. 说出至少4个Vue指令及作用\\n\\n​\\tv-for 根据数组的个数, 循环数组元素的同时还生成所在的标签\\n\\n​\\tv-show 显示内容\\n\\n​\\tv-if    显示与隐藏  \\n\\n​\\tv-else  必须和v-if连用  不能单独使用  否则报错  \\n\\n​\\tv-bind  动态绑定  作用： 及时对页面的数据进行更改, 可以简写成:分号\\n\\n​\\tv-on  给标签绑定函数，可以缩写为@，例如绑定一个点击函数  函数必须写在methods里面\\n\\n​\\tv-text  解析文本\\n\\n​\\tv-html   解析html标签\\n\\n### 9. 为什么避免v-for和v-if在一起使用\\n\\n​\\tVue 处理指令时，v-for 比 v-if 具有更高的优先级, 虽然用起来也没报错好使, 但是性能不高, 如果你有5个元素被v-for循环, v-if也会分别执行5次.      \\n\\n\")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);","extractedComments":[]}